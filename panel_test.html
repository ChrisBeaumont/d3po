<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8" />
        
        <!-- CSS / Styling -->
        <link rel="stylesheet" type="text/css" href="css/style.css">
        
        <!-- Javscript dependencies -->
        <!--<script src="http://d3js.org/d3.v3.min.js"></script>-->
        <script src="js/d3.v3.min.js"></script>
        <script src="js/util.js"></script>
        <script src="http://code.jquery.com/jquery.min.js"></script>
        
    </head>
    
    <body>
        <script>
            var states, 
                csv_data,
                plot_size = 350, // px
                padding = 50; // px 
            
            // Scalers for x / y axes from data space to pixel space
            var xScaler = d3.scale.linear()
                .range([padding/2, plot_size - padding/2]);
            
            var yScaler = d3.scale.linear()
                .range([plot_size - padding/2, padding/2]);
            
            // Read states JSON spec
            d3.json("states.json", function(error, json_data) {
                if (error) {
                    console.warn(error);
                }
                
                // Pull out the array of states from the json file
                states = json_data['states'];
            });
            
            d3.csv("data/sample_data_cut.csv", function(error, data) {
                csv_data = data;
                update_state(states[0]);
            });

           d3.select("body").data(states).enter().append("a").attr("class", "button").html(function(d, i){return i+1})
            
            //<a href="#" class="button">b1</a>
            
            function update_state(state) { 
                var nRows = state['grid']['nRows'],
                    nCols = state['grid']['nColumns'];
                
                var svg_height = nRows*plot_size + padding,
                    svg_width = nCols*plot_size + padding;
                    
                var tickSize = 16;
                
                // Define an object to contain the domains (in data space) for each column
                var domainByDataColumn = {},
                    dataColumns = d3.keys(csv_data[0]);                
                    
                dataColumns.forEach(function(colName) {
                    var domain = d3.extent(csv_data, function(d) { return parseFloat(d[colName]); });
                    
                    // if parseFloat failed, probably string values in the column
                    if (isNaN(domain[0]) || isNaN(domain[1])){
                        var this_col = [];
                        csv_data.map(function(d) {
                            this_col.push(d[colName]);
                        });
                        
                        domainByDataColumn[colName] = this_col.unique();
                    } else {
                        var size = domain[1]-domain[0];
                        domainByDataColumn[colName] = [domain[0] - size/25., 
                                                       domain[1] + size/25.];
                    }
                });
                
                // Define the axis objects
                var xAxis = d3.svg.axis()
                            .scale(xScaler)
                            .orient("bottom")
                            .ticks(5);
                        
                var yAxis = d3.svg.axis()
                            .scale(yScaler)
                            .orient("left")
                            .ticks(5);
                
                xAxis.tickSize(tickSize);
                yAxis.tickSize(tickSize);
                
                // TODO: needs better names, brain dumping...
                var d = [];
                for (var ii=0; ii < state['plots'].length; ii++) {
                    var this_plot = state['plots'][ii];
                    
                    d.push({ xColumnName : this_plot['xAxis'],
                             yColumnName : this_plot['yAxis'],
                             i : this_plot['gridPosition'][0],
                             j : this_plot['gridPosition'][1]
                           });
                }
                
                var xColumnNames = [],
                    yColumnNames = [];
                
                d.map(function(dd) {
                        xColumnNames.push(dd.xColumnName);
                        yColumnNames.push(dd.yColumnName);
                    });
                
                // Define top level svg tag
                var svg = d3.select("body").append("svg")
                                .attr("width", svg_width)
                                .attr("height", svg_height)
                                .append("g")
                                .attr("transform", "translate(" + padding/2. + "," + padding/2. + ")");
                
                // Add axes to the plots
                svg.selectAll(".x.axis")
                  .data(xColumnNames)
                .enter().append("g")
                  .attr("class", "x axis")
                  .attr("transform", function(d, i) { return "translate(" + i*plot_size + "," + (plot_size-padding+tickSize/2) + ")"; })
                  .each(function(d) { xScaler.domain(domainByDataColumn[d]); 
                                      d3.select(this).call(xAxis); 
                        });
                
                svg.selectAll(".y.axis")
                  .data(yColumnNames)
                .enter().append("g")
                  .attr("class", "y axis")
                  .attr("transform", function(d, i) { return "translate(" + (i*plot_size+padding-tickSize/2) + "," + 0 + ")"; })
                  .each(function(d) { yScaler.domain(domainByDataColumn[d]); 
                                      d3.select(this).call(yAxis); 
                        });
                
                var cell = svg.selectAll(".cell")
                              .data(d)
                              .enter().append("g")
                              .attr("class", "cell")
                              .attr("transform", function(d) { 
                                                    return "translate(" + d.j*(plot_size) + "," 
                                                                        + (nRows - d.i - 1)*plot_size + ")"; 
                                                })
                              .each(plot);
                
                // Define the brush object
                var brush = d3.svg.brush()
                              .x(xScaler)
                              .y(yScaler)
                              .on("brushstart", brushstart)
                              .on("brush", brushmove)
                              .on("brushend", brushend);

                cell.call(brush);
                
                var brushCell;

                // Clear the previously-active brush, if any.
                function brushstart(p) {
                    if (brushCell !== this) {
                        d3.select(brushCell).call(brush.clear());
                        xScaler.domain(domainByDataColumn[p.xColumnName]);
                        yScaler.domain(domainByDataColumn[p.yColumnName]);
                        brushCell = this;
                    }
                }
                
                // Highlight the selected circles.
                function brushmove(p) {
                    var e = brush.extent();
                    svg.selectAll("circle").classed("hidden", function(d) {
                          return e[0][0] > d[p.xColumnName] || d[p.xColumnName] > e[1][0]
                                  || e[0][1] > d[p.yColumnName] || d[p.yColumnName] > e[1][1];
                    });
                }
                
                // If the brush is empty, select all circles.
                function brushend() {
                    if (brush.empty()) svg.selectAll(".hidden").classed("hidden", false);
                }
                
                // TODO: wtf
                function plot(p) {
                    var cell = d3.select(this);
                    
                    /* need to do something fancy for histogram here?
                    if (domainByDataColumn[p.xColumnName].length > 2) {
                        // e.g., ordinal domain
                        xScaler = xOrdinalScaler;
                        xScaler.domain(domainByDataColumn[p.xColumnName]);
                    } else {
                        xScaler.domain(domainByDataColumn[p.xColumnName]);
                    }
                    */
                    xScaler.domain(domainByDataColumn[p.xColumnName]);
                    yScaler.domain(domainByDataColumn[p.yColumnName]);
                    
                    cell.append("rect")
                        .attr("class", "frame")
                        .attr("x", padding / 2)
                        .attr("y", padding / 2)
                        .attr("width", plot_size - padding)
                        .attr("height", plot_size - padding);
                    
                    cell.selectAll("circle")
                        .data(csv_data)
                        .enter().append("circle")
                        .attr("cx", function(d) { return xScaler(d[p.xColumnName]); })
                        .attr("cy", function(d) { return yScaler(d[p.yColumnName]); })
                        .attr("r", 2)
                        .style("fill", function(d) { return "#333333"; }); // TODO: COLOR STUFF HERE
                }
            }
            
        </script>
    </body>

</html>